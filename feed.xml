<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-06-04T14:18:51+09:00</updated><id>/</id><title type="html">sysmoon’s blog</title><subtitle>문형권 기술블로그 (sysmoon@sk.com)</subtitle><entry><title type="html">Istio Telemetry (4. Visualizing metrics with Grafana)</title><link href="/istio-telemetry_visualizing_metrics_with_grafana" rel="alternate" type="text/html" title="Istio Telemetry (4. Visualizing metrics with Grafana)" /><published>2018-06-03T19:00:00+09:00</published><updated>2018-06-03T19:00:00+09:00</updated><id>/istio-telemetry_visualizing_metrics_with_grafana</id><content type="html" xml:base="/istio-telemetry_visualizing_metrics_with_grafana">&lt;p&gt;이번 task 에서는 mesh 트래픽을 모니터링 하기 위한 Istio Dashboard 설정과 사용 방법에 대해 소개한다.
이 task 중에 당신은 istio add-on Grafana 와 Service Mesh 트래픽 데이터를 보기 위한 web-based 인터페이스를 사용하게 될 것이다.&lt;/p&gt;

&lt;h1 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터에 Istio를 설치하세요. 만약 설치하는데 Helm을 사용한다면 Grafana add-on –set grafana.enabled=true 옵션을 활성화 하세요&lt;/li&gt;
  &lt;li&gt;Bookinfo 애플리케이션을 배포하세요&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;istio-dashboard-보기&quot;&gt;Istio Dashboard 보기&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;prometheus 서비스가 클러스터 안에서 실행중인 것을 확인하세요.&lt;br /&gt;
쿠버네티스 환경에서 아래 명령어를 실행하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system get svc prometheus
NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
prometheus   10.59.241.54   &amp;lt;none&amp;gt;        9090/TCP   2m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;클러스터에서 Grafana 서비스가 실행중인 것을 확인하세요
쿠버네티스 환경에서 아래 명령어를 실행하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl -n istio-system get svc grafana
NAME      CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
grafana   10.59.247.103   &amp;lt;none&amp;gt;        3000/TCP   2m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Grafana UI를 통해 Istio Dashboard 를 열어보세요.&lt;br /&gt;
쿠버네티스 환경에서 아래 명령어를 실행하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') 3000:3000 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;웹브라우저에서 &lt;a href=&quot;http://localhost:3000/dasboard/db/istio-mesh-dashboard&quot;&gt;http://localhost:3000/dashboard/db/istio-mesh-dashboard&lt;/a&gt; 방문해보세요.&lt;br /&gt;
Istio Dashboard 다음과 유사하게 보여질 것이다.
&lt;img src=&quot;../assets/images/istio/grafana-istio-dashboard.png&quot; alt=&quot;Istio Dashboard&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Service Mesh로 트래픽 전송
Bookinfo 샘플의 경우 http://$GATEWAY_URL/productpage 페이지를 웹에서 접속하거나 아래 명령어를 통해 요청하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$GATEWAY_URL은 Bookinfo 샘플에서 설정된 값입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;약간의 트래픽을 생성하기 위해 페이지를 몇번 갱신한다. (또는 명령얼 몇번 더 수행한다.)&lt;br /&gt;
Istio Dashboard를 다시 한번 본다. 생성된 트래픽이 반양되어 있어야 한다. 다음과 비슷하게 보여진다.
&lt;img src=&quot;../assets/images/istio/dashboard-with-traffic.png&quot; alt=&quot;dashboard-with-traffic&quot; /&gt;
이 대시보드는 Mesh 안에 있는 서비스와 워크로드와 함께 Mesh 의 전체적인 view를 제공한다.&lt;br /&gt;
당신은 아래 설명된 구체적인 대시보드 탐색을 통해 서비스와 워크로드에 대한 디테일한 정보를 얻을 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;서비스 대시보드 시각화
Grafana 대비보드 왼쪽 코너에 있는 탐색 메뉴로부터 Istio Dashboard 를 탐색하거나 &lt;a href=&quot;http://localhost:3000/dashboard/db/istio-service-dashboard&quot;&gt;http://localhost:3000/dashboard/db/istio-service-dashboard&lt;/a&gt; 웹브라우징하여 방문 가능하다.&lt;br /&gt;
istio 서비스 대시보드는 아래와 유사하다.
&lt;img src=&quot;../assets/images/istio/istio-service-dashboard.png&quot; alt=&quot;istio-service-dashboard.png&quot; /&gt;
이 대시보드는 서비스를 위한 client workloads(서비스를 호출하는 workload)와 service workload(이 서비스를 제공하는 워크로드) 그리고 서비스에 대한 자세한 metrics를 제공한다.&lt;/li&gt;
  &lt;li&gt;워크로드 대시보드 시각화
Grafana 대시보드 왼쪽 코너 탐색 메뉴에서 당신은 Istio 워크로드 대시보드를 탐색하거나 &lt;a href=&quot;http://localhost:3000/dashboard/db/istio-workload-dashboard&quot;&gt;http://localhost:3000/dashboard/db/istio-workload-dashboard&lt;/a&gt; 웹브라우징을 통해 접속 가능하다.&lt;br /&gt;
Istio 워크로드 대시보드는 아래와 유사하다.
&lt;img src=&quot;../assets/images/istio/istio-workload-dashboard.png&quot; alt=&quot;istio-workload-dashboard&quot; /&gt;
이 대시보드는 각 워크로드와 inboud 워크로드(이 워크로드에 요청을 보내는 워크로드) 와 해당 워크로드에 대한 outbound service(이 워크로드가 요청을 전송하는 서비스) 에 대한 자세한 mertics를 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;about-the-grafana-add-on&quot;&gt;About the Grafana add-on&lt;/h1&gt;
&lt;p&gt;Grafana add-on은 Grafana의 사전에 이미 구성된 설정이다. 기본 이미지 (&lt;strong&gt;grafana/grafana:5.2.3&lt;/strong&gt;) Prometheus 데이터 소스와 Istio 대시보드가 설치되어 시작되도록 수정되었다. 특히 istio 와 mixer의 기본 설치 파일은 global(모든 서비스에 사용) metrics 기본 설정으로 제공한다. Istio 대시보드는 기본 istio metric 설정과 Prometheus 백엔드와 결합하여 사용되로독 만들어졌다.&lt;/p&gt;

&lt;p&gt;Istio 대시보드의 주요 3가지 구성&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A Mesh Summary View. 이 세션은 Mesh의 전체적인 요약 관점을 제공하고, Mesh 에서 HTTP/gRPC 그리고 TCP 워크로드를 보여준다.&lt;/li&gt;
  &lt;li&gt;Individual Service View. 이 섹션은 Mesh 안에서 각각의 개별적인 서비스를 위한 요청과 응답에 대한 metrics를 제공한다. 이러한 것은 이 서비스를 위한 클라이언트와 서비스 워크로드에 대한 metrics 또한 제공한다.&lt;/li&gt;
  &lt;li&gt;Individual Workloads View. 이 섹션은 Mesh 안에서 각각의 개별적인 워크로드를 위한 요청과 응답에 대한 mertices를 제공한다. 이러한 뷰는 또한 워크로드를 위한 inbound workload 와 outboud service에 대한 metrics 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;대시보드 생성, 설정, 수정에 대한 좀더 자세한 내용은 &lt;a href=&quot;https://grafana.com/docs/&quot;&gt;Grafana Documendation&lt;/a&gt;을 통해 확인 가능하다.&lt;/p&gt;</content><author><name>sysmoon</name></author><category term="k8s" /><summary type="html">이번 task 에서는 mesh 트래픽을 모니터링 하기 위한 Istio Dashboard 설정과 사용 방법에 대해 소개한다. 이 task 중에 당신은 istio add-on Grafana 와 Service Mesh 트래픽 데이터를 보기 위한 web-based 인터페이스를 사용하게 될 것이다.</summary></entry><entry><title type="html">Istio Telemetry (5. Collecting Logs)</title><link href="/istio-logs_collecting_logs" rel="alternate" type="text/html" title="Istio Telemetry (5. Collecting Logs)" /><published>2018-06-03T19:00:00+09:00</published><updated>2018-06-03T19:00:00+09:00</updated><id>/istio-logs_collecting_logs</id><content type="html" xml:base="/istio-logs_collecting_logs">&lt;p&gt;이 task는 Service Mesh를 위해 어떻게 자동 telemetry 수집을 위한 설정을 하는지 보여준다.&lt;/p&gt;</content><author><name>sysmoon</name></author><category term="k8s" /><summary type="html">이 task는 Service Mesh를 위해 어떻게 자동 telemetry 수집을 위한 설정을 하는지 보여준다.</summary></entry><entry><title type="html">Istio Telemetry (2. Collecting Metric for TCP services)</title><link href="/istio-telemetry_metrics_collecting_metrics_for_tcp_services" rel="alternate" type="text/html" title="Istio Telemetry (2. Collecting Metric for TCP services)" /><published>2018-06-03T19:00:00+09:00</published><updated>2018-06-03T19:00:00+09:00</updated><id>/istio-telemetry_metrics_collecting_metrics_for_tcp_services</id><content type="html" xml:base="/istio-telemetry_metrics_collecting_metrics_for_tcp_services">&lt;h1 id=&quot;collecting-metric&quot;&gt;Collecting Metric&lt;/h1&gt;
&lt;p&gt;이번 테스크에서는 서비스 매쉬를 위해 어떻게 telemetry 정보를 자동으로 수집하기 위한 설정을 하는지 보여준다. 마지막 테스크에서는 TCP 서비스를 콜하기 위한 새로운 metric이 활성화 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Istio를 클러스터에 설치 배포하세요.&lt;/li&gt;
  &lt;li&gt;사용하고 있는 K8S 클러스터에 Istio를 설치하고, App을 배포한다. 이 task는 Minxer가 default configuration (–configDefaultNamespace=istio-system) 으로 설정되어 있다고 가정한다.
만약 다른 설정값을 사용하고 있다면, 위 설정으로 업데이트해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;collecting-new-telemetry-data&quot;&gt;Collecting new telemetry data&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 생성과 자동 수집을 위해 아래 YAML 설정 파일을 적용하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f samples/bookinfo/telemetry/tcp-metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;만약 istio &amp;gt;= 1.1.2 이면 다음 설정파일을 대신 사용하세요
kubectl apply -f samples/bookinfo/telemetry/tcp-metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;MongoDB 사용을 위히 Bookinfo를 설정하세요
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;rating&lt;/strong&gt; service v2를 설치합니다.
 만약 automatic sidecar injection 이 활성화 되어있으면, kubectl을 이용하야 간단하게 배포합니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 수동 sidecar injection을 사용한다면, 다음 명령어를 대신 사용하세요&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;mongodb 서비스 설치
 만약 automatic sidecar injection 이 활성화 되어있으면, kubectl을 이용하야 간단하게 배포합니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/platform/kube/bookinfo-db.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 수동 sidecar injection을 사용한다면, 다음 명령어를 대신 사용하세요&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo-db.yaml)
 service &quot;mongodb&quot; configured
 deployment &quot;mongodb-v1&quot; configured
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;Bookinfo 샘플은 각 마이크로서비스 별 다양한 버전을 배포합니다. 그래서 각 서비스 버전별 집합에 대해 정의하고 이에 대한 도착지 규칙과 각 서비스 집합에 대한 로드밸런싱을 위한 도착지 규칙을 생성할 것입니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 TLS가 활성화되어있다면, 다음 설정을 대신 적용하세요.&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/destination-rule-all-mtls.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;다음 명령어로 도착지 규칙을 확인할 수 있다.&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl get destinationrules -o yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;virtual service 에 있는 subset reference가 도착치 규칙에 의존성을 가지고 있기 때문에, virtual service가 subsets을 참조하기 전데 도착치 규칙이 전파되기까지 잠시 기다린다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;rating&lt;/strong&gt;, ** reviews** virtual service를 생성한다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/virtual-service-ratings-db.yaml
 Created config virtual-service/default/reviews at revision 3003
 Created config virtual-service/default/ratings at revision 3004
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;샘플 애플리케이션으로 트래픽을 전송한다.&lt;br /&gt;
Bookinfo 샘플 테스를 위해 http://$GATEWAY_URL/productpage 웹브라우저로 방문하거나 아래 명령어를 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 metric 값이 생성, 수집되는 것을 확인한다.&lt;br /&gt;
쿠버네티스 환경에서 다음 명령어를 통해 Prometheus를 위한 port-forwarding을 설정한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Prometheus UI를 통해 새로운 metric 값을 확인한다.&lt;br /&gt;
제공된 링크는 Prometheus UI를 열고, &lt;strong&gt;istio_mongo_received_bytes&lt;/strong&gt; 값 쿼리를 실행한다.&lt;br /&gt;
&lt;strong&gt;Console&lt;/strong&gt; 탭에 있는 테이블은 아래와 비슷한 entries 를 포함하고 있다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_mongo_received_bytes{destination_version=&quot;v1&quot;,instance=&quot;172.17.0.18:42422&quot;,job=&quot;istio-mesh&quot;,source_service=&quot;ratings-v2&quot;,source_version=&quot;v2&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;understanding-tcp-telemetry-collection&quot;&gt;Understanding TCP telemetry collection&lt;/h1&gt;
&lt;p&gt;이 테스크에서 Mixer가 매쉬 안에 있는 TCP 서비스에게 모든 트래픽에 대한 새로운 metric을 자동으로 생성하고, 보고하도록 지시한 istio 설정을 추가햇습니다.&lt;br /&gt;
Collecting Metrics and Logs Task와 유사하게, 새로운 설정은 instance, handler, rule로 구성되어 있습니다. metric 집한 구성요소의 완벽한 설명을 위한 task를 확인해보세요.&lt;br /&gt;
TCP 서비스의 Metric 집합은 인스턴스에서 사용할 수 있는 제한된 특성 집합에서만 다릅니다.&lt;/p&gt;

&lt;h2 id=&quot;tcp-attributes&quot;&gt;TCP attributes&lt;/h2&gt;
&lt;p&gt;몇몇 TCP-specific 속성들은 istio 에서 TCP 규칙과 컨트롤을 활성화 합니다. 이러한 속성들은 server-side Envoy proxies 에서 생성됩니다. 이러한 속성들은 연결이 살아있을때 (주기적 리포팅), 연결이 수립된 Mixter에게 주기적으로 전송되고, 연결종료를 전송합니다. (마지막 리포트)&lt;br /&gt;
기본 리포트 주기는 10초이고, 최소 1초 이상이어야 합니다. 추가적으로 context 속성들은 규칙안에서
&lt;strong&gt;http&lt;/strong&gt; 와 &lt;strong&gt;tcp&lt;/strong&gt; 프로토콜을 구분할 수 있는 기느을 제공합니다.&lt;br /&gt;
&lt;img src=&quot;../assets/images/istio/tcp_attributes.svg&quot; alt=&quot;TCP attributes&quot; /&gt;&lt;/p&gt;</content><author><name>sysmoon</name></author><category term="k8s" /><summary type="html">Collecting Metric 이번 테스크에서는 서비스 매쉬를 위해 어떻게 telemetry 정보를 자동으로 수집하기 위한 설정을 하는지 보여준다. 마지막 테스크에서는 TCP 서비스를 콜하기 위한 새로운 metric이 활성화 될 것이다.</summary></entry><entry><title type="html">Istio Telemetry (1. Collecting Metrics)</title><link href="/istio-telemetry_collecting_metrics" rel="alternate" type="text/html" title="Istio Telemetry (1. Collecting Metrics)" /><published>2018-06-03T19:00:00+09:00</published><updated>2018-06-03T19:00:00+09:00</updated><id>/istio-telemetry_collecting_metrics</id><content type="html" xml:base="/istio-telemetry_collecting_metrics">&lt;h1 id=&quot;collecting-metric&quot;&gt;Collecting Metric&lt;/h1&gt;
&lt;p&gt;이번 작업은 Service Mesh를 위해 자동으로 telemetry 정보를 수집하기 위한 istio 설정 방법에 대해 알아본다.
마지막 부분에 Service Mesh 안에서 새로운 서비스를 위한 Metric이 활성화 된다.
Bookinfo 샘플 어플케이션이 이 작업을 위해 예제로 활용되기 때문에 먼저 Bookinfo 애플리케이션이 배포되어 있어야 한다.&lt;/p&gt;

&lt;h1 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;사용하고 있는 쿠버네티스 클러스터에 Istio를 설치하고, App을 배포한다. 이 작업은 Mixer가 default configuration (–configDefaultNamespace=istio-system) 이 설정된 것으로 가정한다.
만약 다른 설정값을 사용하고 있다면, 위 설정으로 업데이트해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;collecting-new-metrics&quot;&gt;Collecting new metrics&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 정보를 수집하기 위해 YAML 파일을 적용하면, istio는 필요한 리소스를 생성하고, metic 정보를 자동으로 수집한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f samples/bookinfo/telemetry/metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;만약, istio &amp;gt;= 1.1.2 일 경우, 아래 yaml configuration 적용 필요
kubectl apply -f samples/bookinfo/telemetry/metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;samples/bookinfo/telemetry/metrics-crd.yaml&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Configuration for metric instances
apiVersion: &quot;config.istio.io/v1alpha2&quot;
kind: metric
metadata:
  name: doublerequestcount
  namespace: istio-system
spec:
  value: &quot;2&quot; # count each request twice
  dimensions:
    reporter: conditional((context.reporter.kind | &quot;inbound&quot;) == &quot;outbound&quot;, &quot;client&quot;, &quot;server&quot;)
    source: source.workload.name | &quot;unknown&quot;
    destination: destination.workload.name | &quot;unknown&quot;
    message: '&quot;twice the fun!&quot;'
  monitored_resource_type: '&quot;UNSPECIFIED&quot;'
---
# Configuration for a Prometheus handler
apiVersion: &quot;config.istio.io/v1alpha2&quot;
kind: prometheus
metadata:
  name: doublehandler
  namespace: istio-system
spec:
  metrics:
  - name: double_request_count # Prometheus metric name
    instance_name: doublerequestcount.metric.istio-system # Mixer instance name (fully-qualified)
    kind: COUNTER
    label_names:
    - reporter
    - source
    - destination
    - message
---
# Rule to send metric instances to a Prometheus handler
apiVersion: &quot;config.istio.io/v1alpha2&quot;
kind: rule
metadata:
  name: doubleprom
  namespace: istio-system
spec:
  actions:
  - handler: doublehandler.prometheus
    instances:
    - doublerequestcount.metric
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;샘플 애플리케이션으로 트래픽 전송
Bookinfo (sample application)에 traffic을 전송한다. Bookinfo App의 경우, browser를 통해 http://$GATEWAY_URL/productpage 브라우징 하거나, 아래와 같이 curl을 이용하여 http request 수행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참고로 minikube 환경에서 GATEWAY_URL을 설정하기 위한 방법은 아래 스크립트를 참고한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;http2&quot;)].nodePort}')
export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].nodePort}')
export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 정보가 생생/수집 되고 있는지 확인하다. 쿠버네티스 환경에서 Prometheus를 위한 port-forwarding setup을 위해 다음과 같은 명령어를 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;새로운 metric value 값 확인을 위해 &lt;a href=&quot;http://localhost:9090/graph&quot;&gt;Prometheus UI&lt;/a&gt; 웹브라우저 접속하여 확인한다. 위 제공된 링크는 Prometheus UI 페이지를 열어서, istio_double_request_count metric 값을 쿼리를 실행한다. Console Tab 테이블에 표시된 entry 정보는 다음과 비슷하다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_double_request_count{destination=&quot;details-v1&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;client&quot;,source=&quot;productpage-v1&quot;}   8
istio_double_request_count{destination=&quot;details-v1&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;productpage-v1&quot;}   8
istio_double_request_count{destination=&quot;istio-policy&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;details-v1&quot;}   4
istio_double_request_count{destination=&quot;istio-policy&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;istio-ingressgateway&quot;}   4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;더 많은 metric value 값을 Prometheus에서 쿼리하기 위해 &lt;a href=&quot;&amp;quot;http://istio.io/docs/tasks/telemetry/metrics/querying-metrics&quot;&gt;Querying Istio Metrics&lt;/a&gt;을 참고한다.&lt;/p&gt;

&lt;h1 id=&quot;understanding-the-metrics-configuration&quot;&gt;Understanding the metrics configuration&lt;/h1&gt;
&lt;p&gt;이번 작업에서는 Service Mesh 에서 발생하는 모든 트랙픽에 대한 새로운 metric 정보를 자동으로 생성하고 리포팅하기 위한 설정을 Mixer에 추가했다.
추가된 설정은 Mixer 기능의 3가지 부분을 컨트롤한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;istio attribute 에서 instance(이 예제에서는 metric 값) 생성&lt;/li&gt;
  &lt;li&gt;생성된 인스터스를 processing 할 수 있는 handlers 생성&lt;/li&gt;
  &lt;li&gt;Rule Set에 따라 인스턴스를 handlers 로 전송&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;metrics configuration은 Mixer 가 Prometheus 로 metric value 값을 전달하도록 명시합니다. 이를 위해 3가지 블럭 구성을 사용합니다. instance configuration, handler configuration, and rule configuration.&lt;/p&gt;

&lt;p&gt;The Kind: instance 블럭은 doublerequestcount라는 새로운 메트릭에 대해 생성 된 메트릭 값(또는 인스턴스)에 대한 스키마를 정의합니다. 이 인스턴스 설정은 Mixer에게 Envoy에 의해 보고되는 속성 (및 Mixer 자체에 의해 생성되는 속성)에 근거 해, 임의의 request에 대해서 메트릭 값 생성하는 방법을 지시한다.&lt;/p&gt;

&lt;p&gt;doublerequestcout에 대한 각각의 instance에 대해, 설정은 Mixer가 각 instance 에 대해 값 2를 지원하도록 명시한다. 이유는 Istio는 각각의 request에 대해 instance를 생성하는데, 이건 이 metric 이 수신받은 총 request 수의 2배를 저장하기 때문이다.&lt;/p&gt;

&lt;p&gt;각각의 doublerequestcount에 대한 dimensions 구성은 구체화 되어있다. Dimesions은 다른 필요성과 질의 방향에 따라 metric 데이터를 자르고, 수집하고, 분석하는 방법을 제공한다. 예를들어 특정 응용프로그램 동작 문제를 해결할때 특정 대상 서비스에 대한 요청만 고려하는 것이 바람직할 수 있다.&lt;/p&gt;

&lt;p&gt;설정은 속성 값 및 기본값을 기반으로 이러한 차원의 값을 채우도록 Mixer에 지시합니다. 예를 들어 source dimension의 경우 새로운 구성은 source.workload.name 특성에서 값을 가져 오도록 요청합니다. 그 속성값이 설정되어 있지 않은 경우, 규칙은 Mixer에 디폴트 값 “unknown”을 사용하도록 지시합니다. message dimesion의 경우 기본값 “twice the fun!” 모든 인스턴스에 사용됩니다.&lt;/p&gt;

&lt;p&gt;handler 구성 블록은 &lt;strong&gt;doublehandler&lt;/strong&gt; 라는 hander를 정의한다. handler spec은 Prometheus 어댑터 코드가 받은 메트릭 인스턴스를 Prometheus 백엔드에서 처리 할 수있는 Prometheus 형식의 값으로 변환하는 방법을 구성한다. 이 구성은 &lt;strong&gt;double_request_count&lt;/strong&gt; 이름의 새로운 Prometheus Metric 이름을 명시했다. Prometheus adapter는 &lt;strong&gt;istio_&lt;/strong&gt; 네임스페이스를 접두어로 붙였는데, 이 metric 정보는 Prometheus 에서 &lt;strong&gt;istio_double_request_count&lt;/strong&gt; 로 보여질 것이다. metric은 &lt;strong&gt;doublerequestcount&lt;/strong&gt; instances를 위한 3가지 라벨 매칭 dimention 설정을 가지고 있다.&lt;/p&gt;

&lt;p&gt;Mixer 인스턴스는 instance_name 매개 변수를 통해 Prometheus 메트릭과 일치합니다. instance_name은 Mixer instances(exmaple: doublerequestcount.instance.istio-system)을 위해 fully-qualified 이름이어야 합니다.&lt;/p&gt;

&lt;p&gt;rule 구성은 &lt;strong&gt;doubleprom&lt;/strong&gt; 라는 새로운 규칙을 정의합니다. 이 rule은 Mixer가 모든 doublerequestcount instance를 &lt;strong&gt;doublehandler&lt;/strong&gt; handler로 전송하도록 설정합니다. rule 안에 match 절이 없기 때문에 그리고 rule은 네임스페이스(istio-system) 안에서 default configuration 설정되었기 때문에 rule은 service mesh 안에 있는 모든 request에 대해 동작한다.&lt;/p&gt;

&lt;h1 id=&quot;cleanup&quot;&gt;Cleanup&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;new metric configuraiton 설정을 삭제한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl delete -f samples/bookinfo/telemetry/metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;만약 istio version &amp;gt;= 1.1.2 이면&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl delete -f samples/bookinfo/telemetry/metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;로컬에서 실행되어 동작중인 kubectl port-forward 프로세스를 죽인다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;killall kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;이어지는 후속 task 작업을 계속 진행할 것이 아니라면, &lt;a href=&quot;https://istio.io/docs/examples/bookinfo/#cleanup&quot;&gt;Bookinfo cleanup&lt;/a&gt; 내용을 참고하여 bookinfo 관련 애플리케이션을 shtudown 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>sysmoon</name></author><category term="k8s" /><summary type="html">Collecting Metric 이번 작업은 Service Mesh를 위해 자동으로 telemetry 정보를 수집하기 위한 istio 설정 방법에 대해 알아본다. 마지막 부분에 Service Mesh 안에서 새로운 서비스를 위한 Metric이 활성화 된다. Bookinfo 샘플 어플케이션이 이 작업을 위해 예제로 활용되기 때문에 먼저 Bookinfo 애플리케이션이 배포되어 있어야 한다.</summary></entry><entry><title type="html">Mac 개발환경 구축</title><link href="/macdevenv" rel="alternate" type="text/html" title="Mac 개발환경 구축" /><published>2018-05-30T19:00:00+09:00</published><updated>2018-05-30T19:00:00+09:00</updated><id>/macdevenv</id><content type="html" xml:base="/macdevenv">&lt;h1 id=&quot;introduce&quot;&gt;Introduce&lt;/h1&gt;
&lt;p&gt;맥 개발환경을 세팅하고, 설치 메뉴얼을 정리하자!&lt;/p&gt;

&lt;h1 id=&quot;to-be-install-program&quot;&gt;To be install program&lt;/h1&gt;

&lt;h2 id=&quot;program-list&quot;&gt;Program List&lt;/h2&gt;
&lt;h3 id=&quot;xcode&quot;&gt;xcode&lt;/h3&gt;
&lt;h3 id=&quot;iterm&quot;&gt;iterm&lt;/h3&gt;
&lt;h3 id=&quot;vscode&quot;&gt;vscode&lt;/h3&gt;
&lt;h3 id=&quot;mongodb&quot;&gt;mongodb&lt;/h3&gt;
&lt;h3 id=&quot;mysql&quot;&gt;mysql&lt;/h3&gt;
&lt;h3 id=&quot;chrome&quot;&gt;chrome&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;extensions
    &lt;ul&gt;
      &lt;li&gt;EnPass&lt;/li&gt;
      &lt;li&gt;Grammarly&lt;/li&gt;
      &lt;li&gt;Color Picker&lt;/li&gt;
      &lt;li&gt;LiveReload&lt;/li&gt;
      &lt;li&gt;uBlock Origin&lt;/li&gt;
      &lt;li&gt;privacy badger&lt;/li&gt;
      &lt;li&gt;oneTab&lt;/li&gt;
      &lt;li&gt;JSONViewer&lt;/li&gt;
      &lt;li&gt;Vue devtools&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;system-preferences&quot;&gt;System Preferences&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Trackpad:
System Preferences &amp;gt; Trackpad &amp;gt; Scroll &amp;amp; Zoom: 
I uncheck scroll direction: Natural (It doesn’t feel natural for me)&lt;/li&gt;
  &lt;li&gt;Dock:
System Preferences &amp;gt; Dock
Change the size to small and turn on magnification
I also remove all icons from the dock that I don’t use&lt;/li&gt;
  &lt;li&gt;Avatar:
System Preferences &amp;gt; Users &amp;amp; Groups &amp;gt; Edit Avatar&lt;/li&gt;
  &lt;li&gt;Theme:
macOS Mojave introduced light &amp;amp; dark themes. I still stick with the light theme even though I use dark themes in almost every editor or program that I use. If you want to change this later simply go to System Preferences &amp;gt; General &amp;gt; Appearance&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;finder&quot;&gt;Finder&lt;/h3&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://dev.to/therealdanvega/new-macbook-setup-for-developers-2nma&lt;/li&gt;
&lt;/ul&gt;</content><author><name>sysmoon</name></author><category term="devops" /><summary type="html">Introduce 맥 개발환경을 세팅하고, 설치 메뉴얼을 정리하자!</summary></entry><entry><title type="html">Istio Telemetry (3. Querying Metrics from Prometheus)</title><link href="/istio-telemetry_querying_metrics_from_prometheus" rel="alternate" type="text/html" title="Istio Telemetry (3. Querying Metrics from Prometheus)" /><published>2018-05-28T19:00:00+09:00</published><updated>2018-05-28T19:00:00+09:00</updated><id>/istio-telemetry_querying_metrics_from_prometheus</id><content type="html" xml:base="/istio-telemetry_querying_metrics_from_prometheus">&lt;h1 id=&quot;collecting-metric&quot;&gt;Collecting Metric&lt;/h1&gt;
&lt;p&gt;이번 테스크에서는 Prometheus를 활용헤ㅐ서 istion를 위한 쿼리를 어떻게 하는지 보여준다.&lt;br /&gt;
이 테스크의 일 부분으로써 metric 값 쿼리를 위한 web-based 인터페이스를 사용할 계획이다.&lt;br /&gt;
이 task 전체에서 Bookinfo 샘플 애플리케이션이 사용된다.&lt;/p&gt;

&lt;h1 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h1&gt;
&lt;p&gt;쿠버네티스 클러스에 istion를 설치하고, Bookinfo 샘플 애플리케이션을 배포하세요.&lt;/p&gt;

&lt;h1 id=&quot;querying-istio-metrics&quot;&gt;Querying Istio Metrics&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;클러스터에서 Prometheus 서비스가 동작하고 있는지 확인한다.&lt;br /&gt;
쿠버네티스 환경에서, 아래와 같은 명령어을 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system get svc prometheus
NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
prometheus   10.59.241.54   &amp;lt;none&amp;gt;        9090/TCP   2m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 매쉬로 트래픽을 전송한다.&lt;br /&gt;
Bookinfo 샘플 애플리케이션을 위해, http://$GATEWAY_URL/productpage 웹브라우저 또는 아래 명령어를 통해 접속한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$GATEWAY_URL 은 Bookinfo 예쩨를 위한 환경변수 설정 값이다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Prometheus UI를 오픈한다.&lt;br /&gt;
쿠버네티스 환경에서, 아래와 같은 명령어를 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;브러우저를 통해 &lt;a href=&quot;http://localhost:9090/graph&quot;&gt;http://localhost:9090/graph&lt;/a&gt; 접속한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Promethues 쿼리를 실행한다.
웹페이지 상단 “Expression” 입력창에 아래 텍스트 &lt;strong&gt;istio_requests_totla&lt;/strong&gt; 를 입력한다.&lt;br /&gt;
그리고 &lt;strong&gt;Execute&lt;/strong&gt; 버튼을 클릭한다.&lt;br /&gt;
결과는 아라와 유사하게 나올 것이다.
![Prometheus Query Result][../assets/images/istio/prometheus_query_result.png]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다른 쿼리를 시도해보면:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;productpage&lt;/strong&gt; 서비스에게 전송한 모든 요청 횟수
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_requests_total{destination_service=&quot;productpage.default.svc.cluster.local&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;reviews&lt;/strong&gt; v3 서비스로 전송된 모든 요청 횟수
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_requests_total{destination_service=&quot;reviews.default.svc.cluster.local&quot;, destination_version=&quot;v3&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 쿼리는 현재까지 v3 &lt;strong&gt;reviews&lt;/strong&gt; 서비스에게 전송된 모든 요청 횟수를 결과로 리턴한다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rate(istio_requests_total{destination_service=~&quot;productpage.*&quot;, response_code=&quot;200&quot;}[5m])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;about-the-promethues-add-on&quot;&gt;About the Promethues add-on&lt;/h1&gt;
&lt;p&gt;Mixer는 생성된 mertic 값을 전달하기 위한 end-point 주소를 외부에 오픈하기 위한 &lt;strong&gt;Prometheus&lt;/strong&gt; 어댑터를 내장하고 있다. Prometheus add-on은 Prometheus 서버가 노출된 metric 정보를 수집하기 위해 Mixer endpoint 를 통해 스크래핑하기 위해 사전 설정된다. Prometheus는 Istion metrics 정보들을 쿼리하고 영구적으로 저장하기 위한 메카니즘을 제공한다.&lt;/p&gt;

&lt;p&gt;설정된 Prometheus add-on은 다음과 같은 endpoint를 수집한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;istio-telemetry.istio-system:42422:&lt;/strong&gt; &lt;strong&gt;istio-mesh&lt;/strong&gt; job은 Mixer 에서 생성된 모든 mertics 정보를 리턴한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;istio-telemetry.istio-system:10514:&lt;/strong&gt; &lt;strong&gt;istio-telemetry&lt;/strong&gt; job은 Mixer-specific metrics 값을 리턴한다. 이 endpoint 주소를 활용하여 Mixer 자체를 모니터링하는 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;istio-proxy:15090:&lt;/strong&gt; &lt;strong&gt;envoy-stats&lt;/strong&gt; 는 Envoy에서 생성된 raw 통계값을 리턴합니다.&lt;br /&gt;
Prometheus는 pods애 있는 envoy-porm 노출된 endpoint 를 바라보도록 설정되어 있습니다. add-on 구성은 add-on 프로세스에 의한 데이터의 크기를 제한하기 위해 수집하는 동안 다수의 Envoy Metrics 정보를 걸러냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;istio-pilot.istio-system:10514:&lt;/strong&gt; &lt;strong&gt;pilot&lt;/strong&gt; job은 Pilot-generated 메트릭을 리턴합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;istio-galley.istio-system:10514:&lt;/strong&gt; &lt;strong&gt;gallery&lt;/strong&gt;는 모든 Gallery-generaed metrics 값을 리턴합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;istio-policy.istio-system:10514:&lt;/strong&gt; &lt;strong&gt;istio-policy&lt;/strong&gt;는 모든 policy와 관련된 metrics 값을 리턴합니다.&lt;br /&gt;
Prometheus 쿼리를 위한 좀더 제사한 정보는, &lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/querying/basics/&quot;&gt;querying docs&lt;/a&gt; 문서를 참고하세요&lt;/li&gt;
&lt;/ol&gt;</content><author><name>sysmoon</name></author><category term="k8s" /><summary type="html">Collecting Metric 이번 테스크에서는 Prometheus를 활용헤ㅐ서 istion를 위한 쿼리를 어떻게 하는지 보여준다. 이 테스크의 일 부분으로써 metric 값 쿼리를 위한 web-based 인터페이스를 사용할 계획이다. 이 task 전체에서 Bookinfo 샘플 애플리케이션이 사용된다.</summary></entry><entry><title type="html">Azure IoTHub</title><link href="/azure-iotedge" rel="alternate" type="text/html" title="Azure IoTHub" /><published>2018-05-08T19:00:00+09:00</published><updated>2018-05-08T19:00:00+09:00</updated><id>/azure-iotedge</id><content type="html" xml:base="/azure-iotedge">&lt;h1 id=&quot;introduce&quot;&gt;Introduce&lt;/h1&gt;
&lt;p&gt;Azure IotHub를 이용하여 다양한 IoT 디바이스를 관리하고, Telemetry 정보를 수집하여 Power BI로 분석 가능하다. 또한 IoT 디바이스를 Edge Computing으로 활용하여 IotHub 런타임 위에 ML Conference가 가능한 컨테이너를 내려 다양한 고급 분석이 가능하다.&lt;/p&gt;

&lt;h1 id=&quot;agenda&quot;&gt;Agenda&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Setup Dev Environment
    &lt;ul&gt;
      &lt;li&gt;IotHub&lt;/li&gt;
      &lt;li&gt;DPS (Device Provisioning Service)&lt;/li&gt;
      &lt;li&gt;Cosmos DB&lt;/li&gt;
      &lt;li&gt;ASA (Azure Streaming Analytics)&lt;/li&gt;
      &lt;li&gt;Storage&lt;/li&gt;
      &lt;li&gt;Etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Setup Rasp Pi&lt;/li&gt;
  &lt;li&gt;Run D2C message application on Rasp&lt;/li&gt;
  &lt;li&gt;Provision a device using Azure IoT DPS (X.509 Individual Enrollment)&lt;/li&gt;
  &lt;li&gt;D2C Message, Azure Streaming Analytics, Data Storage/DB&lt;/li&gt;
  &lt;li&gt;Custom Vision Edge module deployment&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;setup-dev-environment&quot;&gt;Setup Dev Environment&lt;/h1&gt;

&lt;h2 id=&quot;prerequsite&quot;&gt;Prerequsite&lt;/h2&gt;
&lt;p&gt;hands-on을 위해 개발 PC에 아래 도구들은 미리 설치한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Visual Studio Code Extension
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.azure-iot-toolkit&quot;&gt;azure-iot-toolkit&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.azure-iot-edge&quot;&gt;azure-iot-edge&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-docker&quot;&gt;docker&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://aka.ms/aziotdevexp&quot;&gt;device exploerer&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/ko-kr/features/storage-explorer/&quot;&gt;Storage Explorer&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;Docker CE&lt;/a&gt;&lt;br /&gt;
Install Docker Community Edition (CE). Don’t sign in Docker Desktop after Docker CE installed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;create-azure-resources&quot;&gt;Create Azure Resources&lt;/h2&gt;

&lt;h3 id=&quot;iothub&quot;&gt;IotHub&lt;/h3&gt;
&lt;h3 id=&quot;dps&quot;&gt;DPS&lt;/h3&gt;
&lt;h3 id=&quot;asa-azure-streaming-analytics&quot;&gt;ASA (Azure Streaming Analytics)&lt;/h3&gt;
&lt;h3 id=&quot;cosmos-db&quot;&gt;Cosmos DB&lt;/h3&gt;
&lt;h3 id=&quot;storage-account&quot;&gt;Storage Account&lt;/h3&gt;

&lt;h1 id=&quot;setup-rasp-pi&quot;&gt;Setup Rasp Pi&lt;/h1&gt;

&lt;h3 id=&quot;install-the-raspbian-operating-system-for-pi&quot;&gt;Install the Raspbian operating system for Pi&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Download Raspbian.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://downloads.raspberrypi.org/raspbian/images/raspbian-2017-07-05/&quot;&gt;Download Raspbian Stretch&lt;/a&gt; (the .zip file)&lt;/li&gt;
      &lt;li&gt;Extract the Raspbian image to a folder on your computer.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Install Raspbian to the microSD card.
    &lt;ul&gt;
      &lt;li&gt;Download and install the Etcher SD card burner utility&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run Etcher and select the Raspbian image that you extracted in step 1.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select the microSD card drive. Etcher may have already selected the correct drive.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click Flash to install Raspbian to the microSD card.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Remove the microSD card from your computer when installation is complete. It’s safe to remove the microSD card directly because Etcher automatically ejects or unmounts the microSD card upon completion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Insert the microSD card into Pi.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;enable-ssh-and-i2c&quot;&gt;Enable SSH and I2C&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Connect Pi to the monitor, keyboard, and mouse. 2. Start Pi and then sign into Raspbian by using pi as the user name and raspberry as the&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;password.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Click the Raspberry icon &amp;gt; Preferences &amp;gt; Raspberry Pi Configuration.
&lt;img src=&quot;../assets/images/iothub/rasp_conf01.png&quot; alt=&quot;iothub_conf&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the Interfaces tab, set I2C and SSH to Enable, and then click OK. If you don’t have
&lt;img src=&quot;../assets/images/iothub/rasp_conf02.png&quot; alt=&quot;iothub_conf&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;physical sensors and want to use simulated sensor data, this step is optional.&lt;/p&gt;

&lt;p&gt;Connect the sensor to Pi (+) 방향 : 3.3V PWR
&lt;img src=&quot;../assets/images/iothub/rasp_conf_gpo01.png&quot; alt=&quot;rasp_conf_gpo01&quot; /&gt;
&lt;img src=&quot;../assets/images/iothub/rasp_conf_gpo02.png&quot; alt=&quot;rasp_conf_gpo02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중간 : GPIO 4&lt;/p&gt;

&lt;p&gt;(-) 방향 : GND&lt;/p&gt;

&lt;p&gt;Connect Pi to the network&lt;/p&gt;

&lt;p&gt;Note IP address of your Pi.&lt;/p&gt;

&lt;h1 id=&quot;run-d2c-message-application-on-rasp&quot;&gt;Run D2C message application on Rasp&lt;/h1&gt;
&lt;p&gt;rasp pi -&amp;gt; IotHub 로 센서데이터를 전송하기 위한 샘플 예제코드는 아래 git url을 통해 다운로드 가능하다.  &lt;a href=&quot;https://github.com/Azure-Samples/azure-iot-samples-python&quot;&gt;azure-iot-samples-python&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;```
git clone https://github.com/Azure-Samples/azure-iot-samples-python&lt;/p&gt;</content><author><name>문형권</name></author><category term="azure" /><category term="iothub" /><summary type="html">Introduce Azure IotHub를 이용하여 다양한 IoT 디바이스를 관리하고, Telemetry 정보를 수집하여 Power BI로 분석 가능하다. 또한 IoT 디바이스를 Edge Computing으로 활용하여 IotHub 런타임 위에 ML Conference가 가능한 컨테이너를 내려 다양한 고급 분석이 가능하다.</summary></entry><entry><title type="html">Azure Machine Learning Architecture</title><link href="/azure-ml-archi" rel="alternate" type="text/html" title="Azure Machine Learning Architecture" /><published>2018-05-08T19:00:00+09:00</published><updated>2018-05-08T19:00:00+09:00</updated><id>/azure-ml-archi</id><content type="html" xml:base="/azure-ml-archi">&lt;h1 id=&quot;azure-ml-architecture&quot;&gt;Azure ML Architecture&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../assets/images/az_ml_archi.png&quot; alt=&quot;Azure ML Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Azure ML Architecture는 기본적으로 BigData 수집/저장/분석을 위한 플랫폼과 큰 차이가 없다.
분석을 위한 플랫폼에 ML을 위한 파이프라인이 들어가 있는 차이점이 있을 뿐이다.
따라서 전체적인 구조는 데이터 수집/저장(실시간/배치) -&amp;gt; 데이터 탐색 -&amp;gt; ML 모델 개발 -&amp;gt; ML 서비스 운영(DW/BI) -&amp;gt; 모니터링 구조로 되어있다.&lt;/p&gt;

&lt;h2 id=&quot;1-데이터-수집-batch-job&quot;&gt;1. 데이터 수집 (Batch Job)&lt;/h2&gt;
&lt;p&gt;원천 데이터가 있는 Data WareHouse (DataBase, Hadoop, File ..) 에서 Batch Job으로 데이터를 로딩한 후, 
ETL Processing을 통해 데이터에 대한 정제작업을 하여 Data Lake or Blob Storage에 저장할 한다.&lt;/p&gt;

&lt;h2 id=&quot;2-데이터-수집-realtime-job&quot;&gt;2. 데이터 수집 (Realtime Job)&lt;/h2&gt;
&lt;p&gt;실시간성 데이터 (Social Network, Network Security Info, Applcation Log) 의 경우 Event Hubs, Kafka와 같은 Pub/Sub 구조의 대용량 로그 큐잉 시스템에 저장하고, 이후 Azure DATABRICS, HDINSIGHT, Stream Analytics와 같은 다양한 종류의 분석 플랫폼을 Consumer로 활용하여 ML 데이터로 활용하기 위한 ETL Processing 이 가능하다. 이후 데이터는 다시 분석용 다양한 종료의 분석용 DB(Cosmos DB, RDB, Redis)에 저장하여, 빅데이터 분석 플랫폼에서 BI를 위한 데이터로 활용하거나, Data Warehouse (Data Lake, Blob Storage)에 저장하여 ML을 위한 데이터 용도로 활용한다.&lt;/p&gt;

&lt;h2 id=&quot;3-데이터-탐색&quot;&gt;3. 데이터 탐색&lt;/h2&gt;
&lt;p&gt;2번 과정에 의해 정제된 데이터는 데이터의 포맷과 활용 용도에 따라 NoSQL, Redis 등 다양한 DB에 저장될 수 있고,
Data Lake, Blob Storage와 같은 형태의 Storage 공간에도 저장될 수 있다. 이러한 다양한 데이터 소스를 통해 데이터를 탐색하여 가져온 후, 주요 KPI 항목에 대한 차트를 대시보드 형태로 꾸며 대시보드를 구성하야 BI 도구로 활용할 수 있고, ML 모델 개발을 위한 데이터로도 활용 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;4-ml-모델-개발&quot;&gt;4. ML 모델 개발&lt;/h2&gt;
&lt;p&gt;Azure는 다양한 데이터 소스를 가져와서 ML 모델을 쉽게 개발할 수 있는 AML(Azure ML) 서비스를 제공하고 있다. ML 모델 개발에 필요한 언어, 도구, 파이프라인 설계 등을 쉽게 할 수 있고, 특히 python 언어를 활용하여 3번 과정에서 탐색한 데이터를 Traning 데이터로 활용하여 모델을 만들고, Expreiment 하고, 모델을 Dockerizing 하여 컨테이너 형태로 원하는 타켓에 배포하기 위한 각 과정을 ML 파이프라인으로 설계가 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;5-ml-모델-배포&quot;&gt;5. ML 모델 배포&lt;/h2&gt;
&lt;p&gt;생성된 ML 모델은 다양한 프레임워크(Tensorflow, Pytorch, Keras..)를 통해 다양한 컴퓨팅 자원(Kubernetes, IoT Edge, FPGA, ML Server, ML Studio Web Service, On-Premise ML Servers…)에 Transfer Learning 되고, Realtime or Batch Job을 통해 들어온 데이터를 Infcluence 한다. Realtime 연계를 위해서는 실시간 수집한 데이터를 기반으로 다양한 Serverless 컴퓨팅 자원(Stream Analytics, Service Fabric, Functions, Logic Apps) 활용이 가능하고, Batch 연계를 위해서는 Azure Databricks, SQL Data 도구를 활용 가능하다.
Realtime or Batch 연계를 통해 ML Confluence 된 데이터 결과물들은 비지니스 앱, Analytics 도구 등 다양한 형태와 연동하여 ML 서비스가 가능하다.&lt;/p&gt;</content><author><name>문형권</name></author><category term="azure" /><category term="ml" /><summary type="html">Azure ML Architecture</summary></entry><entry><title type="html">Azure Machine Learning Reference Site</title><link href="/azure-ml-tech-docs" rel="alternate" type="text/html" title="Azure Machine Learning Reference Site" /><published>2017-07-27T19:00:00+09:00</published><updated>2017-07-27T19:00:00+09:00</updated><id>/azure-ml-tech-docs</id><content type="html" xml:base="/azure-ml-tech-docs">&lt;h1 id=&quot;readme&quot;&gt;Readme&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;DevOps
    &lt;ul&gt;
      &lt;li&gt;Auzre ML, DevOps를 활용하여 데이터 분석 플랫폼 구축&lt;/li&gt;
      &lt;li&gt;샘플 데이터 &amp;amp; 모델 기반으로 DevOps for AI 빌드/릴리즈 파이프라인 설계&lt;/li&gt;
      &lt;li&gt;Model별 버전 관리&lt;/li&gt;
      &lt;li&gt;Model 버전별 precision/recall 결과 비교하여 우수한 Model 자동 배포&lt;/li&gt;
      &lt;li&gt;Azure DevOps 이용하여 신규버전 Container 생성(ACR), 이후 IoT Edge 배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Azure ML Service
    &lt;ul&gt;
      &lt;li&gt;Cloud 환경에서 Data + DL Model 학습 (object detection)&lt;/li&gt;
      &lt;li&gt;DL Model Test dataset 활용하여 precision/recall 등 지표에 대한 계산/표시&lt;/li&gt;
      &lt;li&gt;모델 선정 및 Model Container 생성 (versioning)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Iot Edge 연동
    &lt;ul&gt;
      &lt;li&gt;Vision AI Dev Kit Camera에 Model Container 배포&lt;/li&gt;
      &lt;li&gt;Image와 Prediction한 결과를 Cloud로 전송하여 live prediction 결과 취합&lt;/li&gt;
      &lt;li&gt;Bounding box와 confidence score 값 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
&lt;p&gt;기본 기술문서: https://docs.microsoft.com/en-us/azure/machine-learning/service/&lt;/p&gt;

&lt;p&gt;주요 개념: https://docs.microsoft.com/en-us/azure/machine-learning/service/concept-azure-machine-learning-architecture&lt;/p&gt;

&lt;p&gt;모델관리 개념: https://docs.microsoft.com/en-us/azure/machine-learning/service/concept-model-management-and-deployment&lt;/p&gt;

&lt;p&gt;Pipeline 개념: https://docs.microsoft.com/en-us/azure/machine-learning/service/concept-ml-pipelines&lt;/p&gt;

&lt;p&gt;보안 관련 접근: https://docs.microsoft.com/en-us/azure/machine-learning/service/concept-enterprise-security&lt;/p&gt;

&lt;h1 id=&quot;hackfest&quot;&gt;Hackfest&lt;/h1&gt;

&lt;p&gt;아래 hackfest 사이트를 통해 Azure ML의 전반적인 사용법을 익힐 수 있습니다.
https://github.com/Azure/LearnAI_Azure_ML&lt;/p&gt;

&lt;h1 id=&quot;샘플&quot;&gt;샘플&lt;/h1&gt;

&lt;p&gt;샘플 사용방법: https://docs.microsoft.com/en-us/azure/machine-learning/service/samples-notebooks&lt;/p&gt;

&lt;p&gt;깃허브: https://github.com/Azure/MachineLearningNotebooks&lt;/p&gt;

&lt;p&gt;(여기에 아래 거의 모든 기능들에 대한 샘플이 있으니 가장 유용할 것으로 판단.)&lt;/p&gt;

&lt;p&gt;기능별 상세 가이드는 How-to guides (방법 가이드) 이하 항목으로 나온다.
직관적으로 되어 있어서 원하시는 단계를 찾으시면 되며, 몇 가지만 소개하면 다음과 같습니다:&lt;/p&gt;

&lt;p&gt;개발환경: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-configure-environment&lt;/p&gt;

&lt;p&gt;DataPrep SDK를 이용한 데이터가공: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-transform-data&lt;/p&gt;

&lt;p&gt;Datastore: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-access-data&lt;/p&gt;

&lt;p&gt;원격수행: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-set-up-training-targets&lt;/p&gt;

&lt;p&gt;Tensorflow 기본방식: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-train-tensorflow&lt;/p&gt;

&lt;p&gt;Hyperparameter Tuning: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-tune-hyperparameters&lt;/p&gt;

&lt;p&gt;Automated ML: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-configure-auto-train&lt;/p&gt;

&lt;p&gt;ONNX: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-build-deploy-onnx&lt;/p&gt;

&lt;p&gt;배포: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-deploy-and-where&lt;/p&gt;

&lt;p&gt;실시간 추론: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-consume-web-service&lt;/p&gt;

&lt;p&gt;배치 추론: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-run-batch-predictions&lt;/p&gt;

&lt;p&gt;모니터: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-enable-app-insights&lt;/p&gt;

&lt;p&gt;쿼터관리: https://docs.microsoft.com/en-us/azure/machine-learning/service/how-to-manage-quotas&lt;/p&gt;

&lt;h1 id=&quot;sdk&quot;&gt;SDK&lt;/h1&gt;
&lt;p&gt;Azure ML SDK (설치방법 포함): https://docs.microsoft.com/en-us/python/api/overview/azure/ml/intro?view=azure-ml-py&lt;/p&gt;

&lt;p&gt;Dataprep SDK: https://docs.microsoft.com/en-us/python/api/overview/azure/dataprep/intro?view=azure-dataprep-py&lt;/p&gt;

&lt;p&gt;Monitoring SDK: https://docs.microsoft.com/en-us/python/api/overview/azure/monitoring/intro?view=azureml-monitoring-py&lt;/p&gt;

&lt;h1 id=&quot;etc&quot;&gt;ETC&lt;/h1&gt;
&lt;p&gt;릴리즈 노트: https://docs.microsoft.com/en-us/azure/machine-learning/service/azure-machine-learning-release-notes&lt;/p&gt;

&lt;p&gt;가격체계: https://azure.microsoft.com/ko-kr/pricing/details/machine-learning-service/&lt;/p&gt;

&lt;p&gt;가장 빠른 방법은 아래의 Tutorial 아래에 있는 4개의 샘플을 직접 수행&lt;/p&gt;

&lt;p&gt;MNIST 데이터로 1. 모델 생성, 2. 모델 배포&lt;/p&gt;

&lt;p&gt;NYC Taxi 데이터로 1. 데이터 가공, 2. Automated ML로 모델 생성&lt;/p&gt;

&lt;p&gt;https://docs.microsoft.com/en-us/azure/machine-learning/service/tutorial-train-models-with-aml&lt;/p&gt;</content><author><name>문형권</name></author><category term="azure" /><category term="ml" /><summary type="html">Readme DevOps Auzre ML, DevOps를 활용하여 데이터 분석 플랫폼 구축 샘플 데이터 &amp;amp; 모델 기반으로 DevOps for AI 빌드/릴리즈 파이프라인 설계 Model별 버전 관리 Model 버전별 precision/recall 결과 비교하여 우수한 Model 자동 배포 Azure DevOps 이용하여 신규버전 Container 생성(ACR), 이후 IoT Edge 배포 Azure ML Service Cloud 환경에서 Data + DL Model 학습 (object detection) DL Model Test dataset 활용하여 precision/recall 등 지표에 대한 계산/표시 모델 선정 및 Model Container 생성 (versioning) Iot Edge 연동 Vision AI Dev Kit Camera에 Model Container 배포 Image와 Prediction한 결과를 Cloud로 전송하여 live prediction 결과 취합 Bounding box와 confidence score 값 저장 개요 기본 기술문서: https://docs.microsoft.com/en-us/azure/machine-learning/service/</summary></entry></feed>