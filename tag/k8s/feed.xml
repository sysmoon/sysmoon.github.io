<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/tag/k8s/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-06-03T12:23:56+09:00</updated>
  <id>/tag/k8s/feed.xml</id>

  
  
  

  
    <title type="html">sysmoon’s blog | </title>
  

  
    <subtitle>문형권 기술블로그 (sysmoon@sk.com)</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Istio Telemetry (Collecting Metric for TCP services)</title>
      <link href="/istio-telemetry_metrics_collecting_metrics_for_tcp_services" rel="alternate" type="text/html" title="Istio Telemetry (Collecting Metric for TCP services)" />
      <published>2018-06-03T19:00:00+09:00</published>
      <updated>2018-06-03T19:00:00+09:00</updated>
      <id>/istio-telemetry_metrics_collecting_metrics_for_tcp_services</id>
      <content type="html" xml:base="/istio-telemetry_metrics_collecting_metrics_for_tcp_services">&lt;h1 id=&quot;collecting-metric&quot;&gt;Collecting Metric&lt;/h1&gt;
&lt;p&gt;이번 테스크에서는 서비스 매쉬를 위해 어떻게 telemetry 정보를 자동으로 수집하기 위한 설정을 하는지 보여준다. 마지막 테스크에서는 TCP 서비스를 콜하기 위한 새로운 metric이 활성화 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Istio를 클러스터에 설치 배포하세요.&lt;/li&gt;
  &lt;li&gt;사용하고 있는 K8S 클러스터에 Istio를 설치하고, App을 배포한다. 이 task는 Minxer가 default configuration (–configDefaultNamespace=istio-system) 으로 설정되어 있다고 가정한다.
만약 다른 설정값을 사용하고 있다면, 위 설정으로 업데이트해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;collecting-new-telemetry-data&quot;&gt;Collecting new telemetry data&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 생성과 자동 수집을 위해 아래 YAML 설정 파일을 적용하세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f samples/bookinfo/telemetry/tcp-metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;만약 istio &amp;gt;= 1.1.2 이면 다음 설정파일을 대신 사용하세요
kubectl apply -f samples/bookinfo/telemetry/tcp-metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;MongoDB 사용을 위히 Bookinfo를 설정하세요
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;rating&lt;/strong&gt; service v2를 설치합니다.
 만약 automatic sidecar injection 이 활성화 되어있으면, kubectl을 이용하야 간단하게 배포합니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 수동 sidecar injection을 사용한다면, 다음 명령어를 대신 사용하세요&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;mongodb 서비스 설치
 만약 automatic sidecar injection 이 활성화 되어있으면, kubectl을 이용하야 간단하게 배포합니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/platform/kube/bookinfo-db.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 수동 sidecar injection을 사용한다면, 다음 명령어를 대신 사용하세요&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo-db.yaml)
 service &quot;mongodb&quot; configured
 deployment &quot;mongodb-v1&quot; configured
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;Bookinfo 샘플은 각 마이크로서비스 별 다양한 버전을 배포합니다. 그래서 각 서비스 버전별 집합에 대해 정의하고 이에 대한 도착지 규칙과 각 서비스 집합에 대한 로드밸런싱을 위한 도착지 규칙을 생성할 것입니다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;만약 TLS가 활성화되어있다면, 다음 설정을 대신 적용하세요.&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/destination-rule-all-mtls.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;다음 명령어로 도착지 규칙을 확인할 수 있다.&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl get destinationrules -o yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;virtual service 에 있는 subset reference가 도착치 규칙에 의존성을 가지고 있기 때문에, virtual service가 subsets을 참조하기 전데 도착치 규칙이 전파되기까지 잠시 기다린다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;rating&lt;/strong&gt;, ** reviews** virtual service를 생성한다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply -f samples/bookinfo/networking/virtual-service-ratings-db.yaml
 Created config virtual-service/default/reviews at revision 3003
 Created config virtual-service/default/ratings at revision 3004
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;샘플 애플리케이션으로 트래픽을 전송한다.&lt;br /&gt;
Bookinfo 샘플 테스를 위해 http://$GATEWAY_URL/productpage 웹브라우저로 방문하거나 아래 명령어를 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 metric 값이 생성, 수집되는 것을 확인한다.&lt;br /&gt;
쿠버네티스 환경에서 다음 명령어를 통해 Prometheus를 위한 port-forwarding을 설정한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Prometheus UI를 통해 새로운 metric 값을 확인한다.&lt;br /&gt;
제공된 링크는 Prometheus UI를 열고, &lt;strong&gt;istio_mongo_received_bytes&lt;/strong&gt; 값 쿼리를 실행한다.&lt;br /&gt;
&lt;strong&gt;Console&lt;/strong&gt; 탭에 있는 테이블은 아래와 비슷한 entries 를 포함하고 있다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_mongo_received_bytes{destination_version=&quot;v1&quot;,instance=&quot;172.17.0.18:42422&quot;,job=&quot;istio-mesh&quot;,source_service=&quot;ratings-v2&quot;,source_version=&quot;v2&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;understanding-tcp-telemetry-collection&quot;&gt;Understanding TCP telemetry collection&lt;/h1&gt;
&lt;p&gt;이 테스크에서 Mixer가 매쉬 안에 있는 TCP 서비스에게 모든 트래픽에 대한 새로운 metric을 자동으로 생성하고, 보고하도록 지시한 istio 설정을 추가햇습니다.&lt;br /&gt;
Collecting Metrics and Logs Task와 유사하게, 새로운 설정은 instance, handler, rule로 구성되어 있습니다. metric 집한 구성요소의 완벽한 설명을 위한 task를 확인해보세요.&lt;br /&gt;
TCP 서비스의 Metric 집합은 인스턴스에서 사용할 수 있는 제한된 특성 집합에서만 다릅니다.&lt;/p&gt;

&lt;h2 id=&quot;tcp-attributes&quot;&gt;TCP attributes&lt;/h2&gt;
&lt;p&gt;몇몇 TCP-specific 속성들은 istio 에서 TCP 규칙과 컨트롤을 활성화 합니다. 이러한 속성들은 server-side Envoy proxies 에서 생성됩니다. 이러한 속성들은 연결이 살아있을때 (주기적 리포팅), 연결이 수립된 Mixter에게 주기적으로 전송되고, 연결종료를 전송합니다. (마지막 리포트)&lt;br /&gt;
기본 리포트 주기는 10초이고, 최소 1초 이상이어야 합니다. 추가적으로 context 속성들은 규칙안에서
&lt;strong&gt;http&lt;/strong&gt; 와 &lt;strong&gt;tcp&lt;/strong&gt; 프로토콜을 구분할 수 있는 기느을 제공합니다.&lt;br /&gt;
&lt;img src=&quot;../assets/images/istio/tcp_attributes.svg&quot; alt=&quot;TCP attributes&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>sysmoon</name>
        
        
      </author>

      

      
        <category term="k8s" />
      

      
        <summary type="html">Collecting Metric 이번 테스크에서는 서비스 매쉬를 위해 어떻게 telemetry 정보를 자동으로 수집하기 위한 설정을 하는지 보여준다. 마지막 테스크에서는 TCP 서비스를 콜하기 위한 새로운 metric이 활성화 될 것이다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Istio Telemetry (Collecting Metric)</title>
      <link href="/istio-telemetry_metrics_collecting_metrics" rel="alternate" type="text/html" title="Istio Telemetry (Collecting Metric)" />
      <published>2018-05-28T19:00:00+09:00</published>
      <updated>2018-05-28T19:00:00+09:00</updated>
      <id>/istio-telemetry_metrics_collecting_metrics</id>
      <content type="html" xml:base="/istio-telemetry_metrics_collecting_metrics">&lt;h1 id=&quot;collecting-metric&quot;&gt;Collecting Metric&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../assets/images/istio/istio_archi.png&quot; alt=&quot;istio architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;istio는 각 pods의 Envoy side_car_proxy(Envoy) 에서 생성된 telemery 정보를 Mixer에 통합 수집하여 관리한다.
이 세션에서는 Service Mesh를 위해 자동으로 telemetry 정보를 수집하기 위한 istio congiruation에 대해 알아본다.
마지막 부분에 Service Mesh 안에서 새로운 서비스를 위한 Metric이 활성화 된다.&lt;/p&gt;

&lt;p&gt;Bookinfo sample 어플케이션이 이 task를 위해 예제로 활용되기 때문에 먼저 Bookinfo App 이 먼저 배포되어 있어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;before-you-begin&quot;&gt;Before you begin&lt;/h2&gt;
&lt;p&gt;사용하고 있는 K8S 클러스터에 Istio를 설치하고, App을 배포한다. 이 task는 Minxer가 default configuration (–configDefaultNamespace=istio-system) 으로 설정되어 있다고 가정한다.
만약 다른 설정값을 사용하고 있다면, 위 설정으로 업데이트해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;collecting-new-metrics&quot;&gt;Collecting new metrics&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 정보를 수집하기 위해 YAML 파일을 적용하면, istio는 필요한 리소스를 생성하고, metic 정보를 자동으로 수집한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f samples/bookinfo/telemetry/metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;istio &amp;gt;= 1.1.2 일 경우, 아래 yaml configuration 적용 필요&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f samples/bookinfo/telemetry/metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Bookinfo (sample application)에 traffic 전송한다. Bookinfo App의 경우, browser를 통해 http://$GATEWAY_URL/productpage 브라우징 하거나, 아래와 같이 curl을 이용하여 http request 수행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://$GATEWAY_URL/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참고로 minikube 환경에서 GATEWAY_URL을 설정하기 위한 방법을 아래 방법을 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export INGRESS_HOST=$(minikube ip)  
export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;http2&quot;)].nodePort}')  
export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].nodePort}')  
export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 metric 정보가 생생/수집 되고 있는지 확인하다. 쿠버네티스 환경에서 Prometheus를 위한 port-forwarding setup을 위해 다음과 같은 명령어를 실행한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;새로운 metric value 값 확인을 위해 &lt;a href=&quot;http://localhost:9090/graph?g0.range_input=1h&amp;amp;g0.expr=istio_double_request_count&amp;amp;g0.tab=1&quot;&gt;Prometheus UI&lt;/a&gt; 웹브라우저 접속하여 확인한다. 위 제공된 링크는 Prometheus UI 페이지를 오픈하고, istio_double_request_count metric 값을 쿼리를 실행한다. Console Tab 안에 아래 테이블에 표시된 entry 정보는 다음과 유사하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istio_double_request_count{destination=&quot;details-v1&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;client&quot;,source=&quot;productpage-v1&quot;}   8
istio_double_request_count{destination=&quot;details-v1&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;productpage-v1&quot;}   8
istio_double_request_count{destination=&quot;istio-policy&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;details-v1&quot;}   4
istio_double_request_count{destination=&quot;istio-policy&quot;,instance=&quot;172.17.0.12:42422&quot;,job=&quot;istio-mesh&quot;,message=&quot;twice the fun!&quot;,reporter=&quot;server&quot;,source=&quot;istio-ingressgateway&quot;}   4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 많은 metric value 값을 Prometheus에서 쿼리하기 위해 &lt;a href=&quot;https://istio.io/docs/tasks/telemetry/metrics/querying-metrics/&quot;&gt;Querying Istio Metrics&lt;/a&gt; 을 참고한다.&lt;/p&gt;

&lt;h1 id=&quot;understanding-the-metrics-configuration&quot;&gt;Understanding the metrics configuration&lt;/h1&gt;
&lt;p&gt;이번 task 에서는 service mesh 안에서 발생하는 모든 트랙픽에 대한 새로운 metric 정보를 자동으로 report &amp;amp; generate 하기 위한 설정을 Mixer에 추가했다.
추가된 설정은 Mixer 기능의 3가지 부분을 컨트롤 하도록 했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;istio attribute 에서 instance(이 예제에서는 metric 값)을 생성&lt;/li&gt;
  &lt;li&gt;생성된 인스터스를 processing 할 수 있는 handlers 생성&lt;/li&gt;
  &lt;li&gt;일련의 Rule Set 규칙에 따라 인스턴스를 handlers에 저장&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;metric configuration은 Mixer가 Prometheus에서 metric value 값을 전달하도록 명시합니다. 이것은 3가지 블럭 구성을 사용합니다. instance configuration, handler configuration, and rule configuration.&lt;/p&gt;

&lt;p&gt;구성의 종류 : instance 스탠자는 doublerequestcount라는 새 메트릭에 대해 생성 된 메트릭 값 (또는 인스턴스)에 대한 스키마를 정의합니다. 이 인스턴스 설정은, Mixer에게, Envoy에 의해보고되는 속성 (및 Mixer 자체에 의해 생성되는 속성)에 근거 해, 임의의 요구에 대해서 메트릭스 치를 생성하는 방법을 지시합니다.&lt;/p&gt;

&lt;p&gt;doublerequestcout 에 대한 각각의 instance에 대해, configuration은 Mixer가 각 instance 에 대해 값 2를 지원하도록 명시한다.&lt;/p&gt;

&lt;p&gt;각각의 doublerequestcount에 대한 dimensions 구성은 구체화 되어있다. Dimesions은 다른 필요성과 질의 방향에 따라 metric 데이터를 자르고, 수집하고, 분석하는 방법을 제공한다.&lt;/p&gt;

&lt;p&gt;이러한 설정은 Mixer가 이러한 속성값과 일반적인 값을 기반으로 한 dimensions 값을 생성하도록 지시한다. 예를 들면 source dimension의 경우 새로운 설정은 value 값이 source.workload.name 속성값을 가지도록 요청한다. 만약 속성값이 생성되지 않으면, rule은 Mixer가 unkown default 값을 사용하도록 한다. message dimenstion에 대해 일반적인 값 “tview the fun!” 이 모든 인스턴스에 대해 사용될 것이다.&lt;/p&gt;

&lt;p&gt;handler 구성 블록은 &lt;em&gt;doublehandler&lt;/em&gt; 라는 hander를 정의한다. handler는 Prometheus adapter code가 어떻게 수신한 metric instance를 Prometheus backend에서 프로레싱할 수 있도록 Promethes-formatted value 값으로 변경하여 전달하는지를 명시한다. 이 구성은 &lt;em&gt;double_request_count&lt;/em&gt; 이름의 새로운 Prometheus Metric 이름을 명시했다. Prometheus adapter는 &lt;em&gt;istio_&lt;/em&gt; 네임스페이스를 접두어로 붙였는데, 이 metric 정보는 Prometheus 에서 &lt;em&gt;istio_double_request_count&lt;/em&gt; 로 보여질 것이다. metric은 &lt;em&gt;doublerequestcount&lt;/em&gt; instances를 위한 3가지 라벨 매칭 dimention 설정을 가지고 있다.&lt;/p&gt;

&lt;p&gt;믹서 인스턴스는 instance_name 매개 변수를 통해 Prometheus 메트릭과 일치합니다. instance_name은 Mixer instances(exmaple: doublerequestcount.instance.istio-system)을 위해 fully-qualified 이름이어야 합니다.&lt;/p&gt;

&lt;p&gt;rule 구성은 새로운 rule 이름 &lt;em&gt;doubleprom&lt;/em&gt; 정의합니다. 이 rule은 Mixer가 모든 doublerequestcount instance를 &lt;em&gt;doublehandler&lt;/em&gt; handler로 전송하도록 설정합니다. rule 안에 match 절이 없기 때문에 그리고 rule은 네임스페이스(istio-system) 안에서 default configuration 설정되었기 때문에 rule은 service mesh 안에 있는 모든 request에 대해 동작한다.&lt;/p&gt;

&lt;h1 id=&quot;cleanup&quot;&gt;Cleanup&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;new metric configuraiton 설정을 삭제한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl delete -f samples/bookinfo/telemetry/metrics.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;만약 istio version &amp;gt;= 1.1.2 이면,&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl delete -f samples/bookinfo/telemetry/metrics-crd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;로컬에서 실행되어 동작중인 kubectl port-forward 프로세스를 죽인다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;killall kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;이어지는 후속 task 작업을 계속 진행할 것이 아니라면, &lt;a href=&quot;https://istio.io/docs/examples/bookinfo/#cleanup&quot;&gt;Bookinfo cleanup&lt;/a&gt; 내용을 참고하여 bookinfo 관련 애플리케이션을 shtudown 한다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>sysmoon</name>
        
        
      </author>

      

      
        <category term="k8s" />
      

      
        <summary type="html">Collecting Metric</summary>
      

      
      
    </entry>
  
</feed>
